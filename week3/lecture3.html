<!doctype html>
<html lang="en">
  <!--
       The MIT License (MIT)

       Copyright (c) 2015 Tom Panning

       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:

       The above copyright notice and this permission notice shall be included in
       all copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
       THE SOFTWARE.
     -->
  <head>
    <meta charset="utf-8">
    <title>
      Module system and the Event loop
    </title>
    <meta name="author" content="Edgar Aroutiounian">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/moon.css" id="theme">
    <!-- Printing and PDF exports -->
    <script>
     var link = document.createElement('link');
     link.rel = 'stylesheet';
     link.type = 'text/css';
     link.href = window.location.search.match(/print-pdf/gi)
	      ?  'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css'
	       : 'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/paper.css';
     document.getElementsByTagName('head')[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
      <script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

	<section data-markdown>
	  <script type="text/template">
# Module System and the Event Loop

## Edgar Aroutiounian
---------------------
#### ISTC backend development course, Week-3, Fall 2016
#### Yerevan, Armenia
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
## _Modularity_
--------------------------
Notice something about our programs? They have all been
written as a single file. That is fine for now but as our
projects grow, it will become harder and harder to think
about the code. We need a way to split out our project
into different pieces, this way we can give different
programmers on the team different parts of codebase to work
on.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
## _module system_
--------------------------------
Many modern programming languages have a notion of a module system,
of a way to organize code, examples include `Python`, `Ruby`, `OCaml`.

Some older languages don't have a module system at all, like `C`, `C++`.

The EcmaScript/JavaScript spec originally did not include a module system
since JavaScript programs were just kept inside a `<script>` tag and were
usually quite short.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
## _module system cont..._
------------------
EcmaScript6 introduced a new module system for JavaScript.

it looks like:
```
import React from 'react';
```
But `node` introduced a module system before `ES6`
called `commonjs`. `node` modules are more powerful,
they can be parametrized but `ES6` modules allow for
better static analysis. Because this is a backend class,
we will stay focused on `node` modules.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _node modules_
------------------
The module system is super simple in `node` and you might have already
used it.

```
const fs = require('fs');
```

`require` is a function that comes with the `node` runtime environment,
it is not part of the JavaScript language spec. We give `require` a
string and it looks through module loading path. You can know the local
path with
```
$ npm root
```
and the global system wide path with
```
$ npm root -g
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _node modules cont..._
------------

```
const foo_bar = require('fs');
```
Notice that whatever `require` returns is bound to whatever variable
name you give it. It doesn't have to be the same name as the module name.

1. Note that trying to require a module name that doesn't exist will
   raise an exception.
2. JavaScript files automatically create a module but when you require them
   you don't need to add the `.js` extension.
3. We use the module system to create a notion of public/private.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _our own modules_
---------------------
Now we'll make our own modules. Each JavaScript file run by `node`
gets some special variables, `module` and `exports`.
These variable will let us control what things the modules exposes to the
outside world, aka other modules.
	  </script>
	</section>


	<section data-markdown>
	  <script type="text/template">
### _our own modules..._
------------------------
Imagine this directory structure, each `\` is a directory
```
project
 \
  src
  | first.js
  | second.js
  \
   lib
   | third.js
```
then we can do...

```
// Imagine this is second.js
const first = require('./first');
const another = require('./lib/third');
```
	  </script>
	</section>
	<section data-markdown>
	  <script type="text/template">
### _our own modules..._
------------------------
So let's finally make modules!

```
// Imagine this is ex.js
exports.name = 'Hello World';
exports.make_upper = str => str.toUpperCase();
exports.fancy = function() {
  console.log(this.name.toUpperCase());
}
```
Then we can load up the `node` repl
```
$ node
> const g = require('./ex');
```
And you can play with it, question, what does `this` bind to in the
`fancy` function? (The `exports` variable is just a JavaScript object.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _our own modules..._
------------------------
Note that the module only exposes what was explicitly assigned to
`exports`. This way we provide a public interface, everything not
assigned to `exports` is hidden. This is how we do public/private in
`node`.
```
// Imagine this is ex.js

// This fat arrow function, func, is only visible inside the module.
// other modules can't see it, can't use it directly.
const func = () => console.log('Some silly function');

exports.name = 'Hello World';
exports.make_upper = str => str.toUpperCase();
exports.fancy = function() {
  func();
  console.log(this.name.toUpperCase());
};
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _our own modules..._
------------------------
Notice that we had to use `exports` for each value we wanted
exposed. There is a nice short cut by using the `module` variable.

```
// Image this is ex.js
const some_hidden_value = 'barev';
module.exports = {
  name : 'name',
  make_upper : str => str.toUpperCase(),
  // Notice we use the short cut for defining functions
  // in a JavaScript object literal
  fancy() {
    console.log(some_hidden_value);
    console.log(this.name.toUpperCase());
  }
};
```
And the usage is the exact same:
```
$ node
> require('./ex').make_upper('hello')
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _our own modules..._
------------------------

And here is how `node` modules are more powerful than
`ES6` modules, you can paramertize them, that is make custom modules
based on given values.

```
// Imagine called ex.js
module.exports = param => {
  switch(param) {
  case 'special':
    return {spot: 10, names : ['hello', 'world']};
  default:
    return {spot : -10, names : []};
  }
};
```

```
$ node
> require('./ex')();
> require('./ex')('special');
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _Some Notes about modules in node_
-------------------------------------
1. modules in node are `cached`, that means that
   you can the same value on `require` each time you load it.
   if you want the module to be fresly loaded each time you use
   it with `require` then do the `module.exports = <a function>`
   trick that was shown previously.

2. All the modules that come with node, aka the standard library
   and offically called `node core` are compiled into the `node`
   binary, like `fs` and `http`. You can look at their documentation
   [here](https://nodejs.org/api/)

3. Even if you name your file `http.js` and try to load it
   with `require('http')`, node will still pick its core module.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">

	  </script>
	</section>
	<section data-markdown>
	  <script type="text/template">

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">

	  </script>
	</section>

  <section data-markdown>
	  <script type="text/template">

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: control structure cont..._
-------------------------------------------
Control structures help us structure, organize our code, which way
it should 'go', what it should do.

The conditional can also take an `else`
```
if (5 < 3) {
  console.log('This is impossible);
} else {
  console.log('Of course 5 is not less than 3');
}
```
Another loop construct is the `while` control structure.
```
let i = 0;
while (i < 4) {
  console.log('Keep talking');
  // i++ is short for i = i + 1;
  i++
}
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects_
---------------------------------
Now we need to talk about containers. A container is something that contains other
things! Let's say we want to talk about all the students in the classroom, how
can we use one variable to talk about all those students? The easiest way is to
use something an `array`.

```
let students = ['Միքայել', 'Gohar', 'Владимир'];
```
`students` is an array and its size is three.
You can make an array by using `[]`, for example
```
let emp = []
```
makes a variable `emp` which starts as an empty array.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects cont..._
-----------------------------------------
We can access elements in the arrays by indexing.

```
// Arrays start from a 0 index.
//               0          1            2
let students = ['Միքայել', 'Gohar', 'Владимир'];
console.log(students[1]);
```
If you try to access an element out of bounds, out of the range of the
array then you get `undefined` (A mistake in the language)
```
console.log(students[42]);
```
And that will print undefined to the terminal screen.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects cont..._
-----------------------------------------
Objects in JavaScript are a way to keep keys and values. Think of a phonebook,
we want to say someone's name is associated with a mobile number.

```
const friends = {Gevorg: '09-34231', Sammy: '08-23123'};
console.log(friends.Gevorg);
console.log(friends['Sammy']);
```

We make JavaScript objects with `{}` and pairs of keys, values.
So `Gevorg` is a key and its value is `'09-34231'`. The size of our
`friends` object is two.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects cont..._
-----------------------------------------
We can loop over arrays; using the old style for loop.
```
const students = ['Միքայել', 'Gohar', 'Владимир'];
for (let i = 0; i < students.length; i++) {
  console.log(students[i]);
}
```
Notice that the `students` variable as a property called length. A property is
anything that can be accessed with `.` of an identifier. I recommend that for that kind of
logic you use the new style for loop.
```
const students = ['Միքայել', 'Gohar', 'Владимир'];
// If we don't want to mutate s, then we use const, otherwise use let
for (const s of students) {
  console.log(s.toUpperCase());
}
```
	  </script>
	</section>

  <section data-markdown>
    <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects cont..._
-----------------------------------------------
if you need to make sure that you have a collection of only unique things, then
you need to use a `Set`

```
// iterable will only have the elements 1 2 3
const iterable = new Set([1, 1, 2, 2, 3, 3]);
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Arrays, Sets, Maps, Objects cont..._
-----------------------------------------------------
Another collection type is called `Map`. Maps are new in EcmaScript 6

```
const iterable = new Map([["a", 1], ["b", 2], ["c", 3]]);
for (const [key, value] of iterable) {
  console.log(value);
}
```

Notice that there's a common theme, having an ability to go over
one thing at a time of a collection. This is called `iterating` over
a collection.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Functions_
---------------------------
Notice how we've been writing the code. We've been just writing
it at the top level, at the file level. The code is not **reusable**.

To fix that, we use **functions**. A function is a block of code that
runs whenever we **call** the function. Functions are also values in
JavaScript which means that we can put them in variables, in arrays.

This is very powerful, some programming languages do not accept
functions as values, for example Java.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Functions cont..._
-----------------------------------

Here is a simple example, we make a function, assign it to
the constant variable `speaker` and then call the variable
as a function. Note that variables inside a function are
block scoped and will be deleted after the function returns,
aka finishes.

```
const speaker = function() {
  console.log('Hello world');
};

speaker();
```
functions in JavaScript don't have to explicitly give back a value.
If you don't have a `return` then the function gives back `undefined`
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Functions cont..._
-----------------------------------

Functions can take data, we call that data the **parameters** of
the function.

```
const speaker = function(param) {
  console.log(param);
};

const s = 'Hello World';
speaker(s);
```
The actual data given to the function is called its **arguments**.
Here we called the variable speaker as a function with the
argument `s` which was a variable for the data `'Hello World'`.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Functions cont..._
-----------------------------------
JavaScript functions are also **vararg** functions, that means that
the functions can take as many arguments as given, even if the
function has less parameters than the number of arguments given to it.

```
const speaker = function(param1, param2) {
  console.log(param1);
  console.log(param2);
}
// Not an error
speaker('Foo', 'Bar', 'Baz', 'Catz');
```
All the arguments given to a function are stored in the variable
`arguments`, it is only accessible inside a function scope.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Functions cont..._
-----------------------------------
Modern `ES6` lets you collect all the argument in a variable using `...`
```
const speaker = function(param1, param2, ...rest) {
  // param1 is 'Foo', param2 is 'Bar'
  // ...rest is an array with 'Baz', 'Catz'
  console.log(param1);
  console.log(param2);
}
speaker('Foo', 'Bar', 'Baz', 'Catz');
```
You can also provide default values
```
const speaker = function(param1, param2='World') {
  console.log(param1 + param2);
}
speaker('Hello');
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
One of the hardest things to understand in JavaScript is
the `this` variable, also known as the execution context.

The `this` variable refers to the current `object`.

```
const obj = {
  name: 'mari',
  speak: function() {
    console.log(this.name);
  }
};
obj.speak();
```
The `this` variable is **dynamically** scoped, this means that its
changes and doesn't use the data that you might think it does when
you use it.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
The `this` variable is a part of the `EcmaScript` spec, that means
that its part of the language but its implementation depends on what
environment you're running your JavaScript code in. In the browser it
refers to the `window` object, in `node` it refers to the global object.
Open the `node` repl and type `this`, you'll see the global object printed.
```
$ node
> this
{ DTRACE_NET_SERVER_CONNECTION: [Function],
  DTRACE_NET_STREAM_END: [Function],
  DTRACE_HTTP_SERVER_REQUEST: [Function],
  DTRACE_HTTP_SERVER_RESPONSE: [Function],
  DTRACE_HTTP_CLIENT_REQUEST: [Function],
  DTRACE_HTTP_CLIENT_RESPONSE: [Function],
  global: [Circular],
  process:
  process {
    title: 'node',
```
	  </script>
	</section>


	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
JavaScript functions also have methods on them and the most
important ones are `bind`, `call`, and `apply`.

Another way to call a function
```
const f = function(g) { console.log(g)}
// call just takes all the arguments you give it
// and passes it to the function you are calling with .call
f.call(null, 'hello')
```
You can also use `.apply` but for apply you need to give an
array of arguments.
```
const f = function(g, h) { console.log(g + h)}
f.apply(null, ['hello', 'world'])
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
Notice that for both `.call` and `.apply` we gave `null`.
This means that we aren't going to provide a custom execution context,
that the function will get to use whatever the `this` variable would
have been. Now we will control the execution context:

```
const obj = {
  name: 'mari',
  speak: function() {
    console.log(this.name);
  }
};
const other_obj = { name:'nane' };
obj.speak.call(other_obj);
```
Run this code and you'll see that `nane` is printed to the screen, not `mari`.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
Now we will talk about the most powerful and important
method on functions, `.bind`. The big annoyance in
JavaScript is that the execution context, the `this`
variable that you end up using at runtime is not always
the one you think will be used. This is because the `this`
variable is `dynamically` scoped, not `lexically` scoped.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
To make sure that the our function uses the execution
content that we want used we have to use `.bind`.

`.bind` creates a new function that uses the execution context
that you provide.
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------

```
const obj = {
  name:'aram'
};
// At the top level this refers to the global object
this.name = 'gohar';
const g = function(last_name) {
// This is using ES6 string interpolation, aka the ${}
  return `${this.name.toUpperCase()} ${last_name}`;
}
const f = g.bind(obj)
console.log(f('baz'));
```

So `f` is a new function which is bound, we did a bind on g,
to the JavaScript object `obj`.

We can also do other wacky things with `.bind` like partial
function application.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: execution context cont..._
-------------------------------------------
Partial function application is like making a new function
from another function but where some of the arguments are used
with other values; its clearer with an example.

```
const obj = {
  name:'aram'
};
// At the top level this refers to the global object
this.name = 'gohar';
const g = function(last_name, age) {
  return `${this.name} ${last_name} ${age}`;
}
// The first argument must always be the new execution context
// and the other arguments end up being the
// arguments of the original function
const f = g.bind(obj, 'baz');
console.log(f(22));
```
See how `'baz'` ends up taking the argument value of `last_name`,
this is positional.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Fat Arrows_
----------------------------
Now we're going to talk about a new feature of the
JavaScript langauge, part of ES6, called `fat arrows`.

Fat arrow functions are like regular functions except
for some syntax differences and what execution context
they use; they use the `this` variable from its lexical scope.

We will be using them extensively, they are
very fun.

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Fat Arrows cont..._
------------------------------------
```
const f = function(first, second) {
  return first + second;
}
```

is the same thing as:

```
const g = (first, second) => {
  return first + second;
}
```
Notice that we don't have to write `function`, less typing
for us and we use `=>`

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Fat Arrows cont..._
------------------------------------
if your function takes only one parameter, then you don't
need `()` for the parameter list.

```
const g = name => {
  return `Hi: ${name.toUpperCase()}`;
}
```
If the function is only one expression, then you don't need
`{}` or even `return`
```
const g = name => `Hi: ${name.toUpperCase()}`;
```
This makes it super fun to use fat arrow functions with things like
`.map` and `.filter`.

```
const evens = [1, 2, 3, 4, 5, 6, 7].filter(x => x % 2 === 0);
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Objects again_
-------------------------------
Notice that we made objects directly, JavaScript objects are
the way to make new data types.

The way to make new data types is to use....functions!

Will this work? Try it.

```
const Person = function(first_name, last_name) {
  this.f_name = first_name;
  this.l_name = last_name;
  this.speak = function() {
    console.log(`My name is: ${this.f_name} ${this.l_name}`);
  }
}
const armo = Person('famous', 'gampr');
armo.speak();
```
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Objects again_
-------------------------------
The previous example didn't work because it matters **how** we
call a function, do we call it as a **function** or
like a **constructor**. In the previous example we
called Person like a function and so the
execution that it used ended up being the global object because the
function wasn't bound to a particular `this` variable and so it kept
looking up in the scope chain until it found one. You can think of
this like doing `cd ..` in the shell, eventually
you will hit `/` and you can't go any higher than `/`, similiarly
the global `this` variable is always available. Check `this.f_name`,
you'll see it has 'famous' attached to it, not a good thing.

(fat arrows can't be called as constructors)
	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Objects again_
-------------------------------
So we need to make sure that we get a **new** execution context
when we call the function, we need to call the function as a constructor

```
const Person = function(first_name, last_name) {
  // if this is now called as a constructor, that is
  // if called used `new` then `this` is just an empty
  // JavaScript object, its {} and here we are assigning
  // new properties to it.
  this.f_name = first_name;
  this.l_name = last_name;
  this.speak = function() {
    console.log(`My name is: ${this.f_name} ${this.l_name}`);
  }
}
const armo = new Person('famous', 'gampr');
armo.speak();
```

	  </script>
	</section>
	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Classes_
-------------------------------
Notice that it wasn't an error to call the function
as a constructor or as a function, `node` was okay
with either, you only got an error when you tried to
use a property that didn't exist.

A convention emerged that functions with uppercase names
were meant to be called as constructors.

This was still error prone so ES6 introduced `classes`

	  </script>
	</section>

	<section data-markdown>
	  <script type="text/template">
### _JavaScript: Classes cont..._
---------------------------------

```
class person {
  constructor(name, last_name) {
    this.f_name = name;
    this.last_name = last_name;
  }
  speak () {
    console.log(`My name is : ${this.f_name} ${this.last_name});
  }
}
const gor = new person('gor', 'gampr');
gor.speak();
```
Notice, if we don't call person with `new` then we'll
get an TypeError exception.

	  </script>
	</section>


      </div>
    </div>

    <script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
    <script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.min.js"></script>

    <script>
     // Full list of configuration options available at:
     // https://github.com/hakimel/reveal.js#configuration
     Reveal.initialize({
       slideNumber:true,
       controls: true,
       progress: true,
       history: true,
       center: true,
       transitionSpeed:'slow',
       previewLinks:true,
       transition: 'convex', // none/fade/slide/convex/concave/zoom
       // Optional reveal.js plugins
       dependencies: [
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/classList.js',
	   condition: function() { return !document.body.classList; } },
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/marked.js',
	   condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/markdown.js',
	   condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/highlight/highlight.js',
	   async: true,
	   condition: function() { return !!document.querySelector( 'pre code' ); },
	   callback: function() { hljs.initHighlightingOnLoad(); } },
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/zoom-js/zoom.js', async: true },
	 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/notes/notes.js', async: true }
       ]
     });
    </script>
  </body>
</html>
